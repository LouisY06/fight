<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Red Stick Detection Test (OpenCV.js)</title>
<style>
  body {
    margin: 0;
    background: #111;
    color: #fff;
    font-family: monospace;
    display: flex;
    flex-direction: column;
    align-items: center;
    padding: 20px;
  }
  h1 { margin-bottom: 10px; }
  .container {
    display: flex;
    gap: 20px;
    flex-wrap: wrap;
    justify-content: center;
  }
  .panel {
    display: flex;
    flex-direction: column;
    align-items: center;
  }
  .panel label {
    margin-bottom: 4px;
    font-size: 14px;
    color: #aaa;
  }
  video, canvas {
    border: 2px solid #333;
    border-radius: 4px;
  }
  #overlay {
    position: absolute;
    pointer-events: none;
  }
  .video-wrap {
    position: relative;
    display: inline-block;
  }
  #info {
    margin-top: 20px;
    padding: 15px;
    background: #222;
    border-radius: 8px;
    min-width: 600px;
    font-size: 16px;
    line-height: 1.8;
  }
  #info .detected { color: #0f0; font-weight: bold; }
  #info .not-detected { color: #f44; font-weight: bold; }
  .bar-wrap {
    display: inline-block;
    width: 200px;
    height: 16px;
    background: #333;
    border-radius: 3px;
    vertical-align: middle;
    margin-left: 8px;
  }
  .bar-fill {
    height: 100%;
    border-radius: 3px;
    transition: width 0.1s;
  }
  #thresholds {
    margin-top: 15px;
    padding: 15px;
    background: #1a1a1a;
    border-radius: 8px;
    min-width: 600px;
  }
  #thresholds label {
    display: block;
    margin: 6px 0;
  }
  #thresholds input[type=range] {
    width: 200px;
    vertical-align: middle;
  }
  .pixel-info {
    margin-top: 10px;
    padding: 10px;
    background: #1a1a1a;
    border-radius: 8px;
    min-width: 600px;
    font-size: 13px;
    color: #888;
  }
  #cvStatus {
    padding: 8px 16px;
    border-radius: 4px;
    margin-bottom: 10px;
    font-weight: bold;
  }
  .cv-loading { background: #553; color: #ffa; }
  .cv-ready { background: #253; color: #0f0; }
  .cv-failed { background: #533; color: #f44; }
</style>
</head>
<body>

<h1>Red Stick Detection Test</h1>
<div id="cvStatus" class="cv-loading">Loading OpenCV.js...</div>
<p>Hold a red object in front of the camera. Click on the video to inspect pixel color.</p>

<div class="container">
  <div class="panel">
    <label>Webcam Feed (640x480)</label>
    <div class="video-wrap">
      <video id="webcam" width="640" height="480" autoplay playsinline muted></video>
      <canvas id="overlay" width="640" height="480"></canvas>
    </div>
  </div>

  <div class="panel">
    <label>Detection Mask (160x120)</label>
    <canvas id="mask" width="480" height="360" style="image-rendering: pixelated;"></canvas>
  </div>
</div>

<div id="info">Starting webcam...</div>

<div id="thresholds">
  <strong>HSV Thresholds (OpenCV: H 0-180, S/V 0-255):</strong>
  <label>Hue Low Range: 0 - <input type="range" id="hueHigh1" min="2" max="30" value="8"> <span id="hueHigh1_val">8</span></label>
  <label>Hue High Range: <input type="range" id="hueLow2" min="150" max="179" value="172"> <span id="hueLow2_val">172</span> - 180</label>
  <label>Min Saturation: <input type="range" id="satMin" min="0" max="255" value="77"> <span id="satMin_val">77</span>/255</label>
  <label>Min Value: <input type="range" id="valMin" min="0" max="255" value="51"> <span id="valMin_val">51</span>/255</label>
  <label>Min Contour Area: <input type="range" id="minArea" min="10" max="500" value="50"> <span id="minArea_val">50</span> px</label>
</div>

<div id="pixelInfo" class="pixel-info">Click on the webcam feed to inspect a pixel's RGB and HSV values.</div>

<script src="opencv/opencv.js" async></script>
<script>
const PROCESS_W = 160;
const PROCESS_H = 120;

const video = document.getElementById('webcam');
const overlayCanvas = document.getElementById('overlay');
const overlayCtx = overlayCanvas.getContext('2d');
const maskCanvas = document.getElementById('mask');
const maskCtx = maskCanvas.getContext('2d');
const infoDiv = document.getElementById('info');
const pixelInfoDiv = document.getElementById('pixelInfo');
const cvStatusDiv = document.getElementById('cvStatus');

// Processing canvas (offscreen)
const procCanvas = document.createElement('canvas');
procCanvas.width = PROCESS_W;
procCanvas.height = PROCESS_H;
const procCtx = procCanvas.getContext('2d', { willReadFrequently: true });

// Full-res canvas for pixel inspection
const inspectCanvas = document.createElement('canvas');
inspectCanvas.width = 640;
inspectCanvas.height = 480;
const inspectCtx = inspectCanvas.getContext('2d', { willReadFrequently: true });

let cvLoaded = false;

// Threshold sliders
const sliders = {
  hueHigh1: document.getElementById('hueHigh1'),
  hueLow2: document.getElementById('hueLow2'),
  satMin: document.getElementById('satMin'),
  valMin: document.getElementById('valMin'),
  minArea: document.getElementById('minArea'),
};
for (const [key, el] of Object.entries(sliders)) {
  el.addEventListener('input', () => {
    document.getElementById(key + '_val').textContent = el.value;
  });
}

// Wait for OpenCV
function waitForOpenCV() {
  return new Promise((resolve) => {
    const check = () => {
      if (typeof cv !== 'undefined' && cv.Mat) {
        cvLoaded = true;
        cvStatusDiv.textContent = 'OpenCV.js Ready';
        cvStatusDiv.className = 'cv-ready';
        resolve();
      } else if (typeof cv !== 'undefined' && cv.onRuntimeInitialized !== undefined) {
        cv.onRuntimeInitialized = () => {
          cvLoaded = true;
          cvStatusDiv.textContent = 'OpenCV.js Ready';
          cvStatusDiv.className = 'cv-ready';
          resolve();
        };
      } else {
        setTimeout(check, 100);
      }
    };
    check();
    // Timeout after 30s
    setTimeout(() => {
      if (!cvLoaded) {
        cvStatusDiv.textContent = 'OpenCV.js failed to load — using manual fallback';
        cvStatusDiv.className = 'cv-failed';
        resolve();
      }
    }, 30000);
  });
}

function rgbToHsv(r, g, b) {
  const rn = r / 255, gn = g / 255, bn = b / 255;
  const max = Math.max(rn, gn, bn);
  const min = Math.min(rn, gn, bn);
  const d = max - min;
  let h = 0;
  if (d !== 0) {
    if (max === rn) h = 60 * (((gn - bn) / d) % 6);
    else if (max === gn) h = 60 * ((bn - rn) / d + 2);
    else h = 60 * ((rn - gn) / d + 4);
  }
  if (h < 0) h += 360;
  const s = max === 0 ? 0 : d / max;
  return [h, s, max];
}

// Click to inspect pixel
overlayCanvas.style.cursor = 'crosshair';
overlayCanvas.addEventListener('click', (e) => {
  const rect = overlayCanvas.getBoundingClientRect();
  const x = Math.floor((e.clientX - rect.left) * (640 / rect.width));
  const y = Math.floor((e.clientY - rect.top) * (480 / rect.height));
  inspectCtx.drawImage(video, 0, 0, 640, 480);
  const px = inspectCtx.getImageData(x, y, 1, 1).data;
  const [h360, s1, v1] = rgbToHsv(px[0], px[1], px[2]);
  // Also show OpenCV-scale HSV
  const hCv = Math.round(h360 / 2);
  const sCv = Math.round(s1 * 255);
  const vCv = Math.round(v1 * 255);
  pixelInfoDiv.innerHTML =
    `<b>Pixel (${x}, ${y}):</b> ` +
    `RGB(${px[0]}, ${px[1]}, ${px[2]}) ` +
    `HSV(${h360.toFixed(1)}°, ${(s1*100).toFixed(0)}%, ${(v1*100).toFixed(0)}%) ` +
    `OpenCV HSV(${hCv}, ${sCv}, ${vCv}) ` +
    `<span style="display:inline-block;width:20px;height:20px;background:rgb(${px[0]},${px[1]},${px[2]});vertical-align:middle;border:1px solid #666;margin-left:8px"></span>`;
});

// OpenCV-based detection
let cvSrc, cvHsv, cvMask1, cvMask2, cvMask, cvMorphKernel, cvContours, cvHierarchy;
let cvInited = false;

function initCvMats() {
  cvSrc = new cv.Mat(PROCESS_H, PROCESS_W, cv.CV_8UC4);
  cvHsv = new cv.Mat();
  cvMask1 = new cv.Mat();
  cvMask2 = new cv.Mat();
  cvMask = new cv.Mat();
  cvMorphKernel = cv.getStructuringElement(cv.MORPH_ELLIPSE, new cv.Size(3, 3));
  cvContours = new cv.MatVector();
  cvHierarchy = new cv.Mat();
  cvInited = true;
}

function detectOpenCV(imageData) {
  if (!cvInited) initCvMats();

  const hueHigh1 = parseInt(sliders.hueHigh1.value);
  const hueLow2 = parseInt(sliders.hueLow2.value);
  const satMin = parseInt(sliders.satMin.value);
  const valMin = parseInt(sliders.valMin.value);
  const minArea = parseInt(sliders.minArea.value);

  cvSrc.data.set(imageData.data);
  cv.cvtColor(cvSrc, cvHsv, cv.COLOR_RGBA2RGB);
  cv.cvtColor(cvHsv, cvHsv, cv.COLOR_RGB2HSV);

  const low1 = new cv.Mat(PROCESS_H, PROCESS_W, cv.CV_8UC3, new cv.Scalar(0, satMin, valMin, 0));
  const high1 = new cv.Mat(PROCESS_H, PROCESS_W, cv.CV_8UC3, new cv.Scalar(hueHigh1, 255, 255, 0));
  const low2 = new cv.Mat(PROCESS_H, PROCESS_W, cv.CV_8UC3, new cv.Scalar(hueLow2, satMin, valMin, 0));
  const high2 = new cv.Mat(PROCESS_H, PROCESS_W, cv.CV_8UC3, new cv.Scalar(180, 255, 255, 0));

  cv.inRange(cvHsv, low1, high1, cvMask1);
  cv.inRange(cvHsv, low2, high2, cvMask2);
  cv.bitwise_or(cvMask1, cvMask2, cvMask);

  cv.morphologyEx(cvMask, cvMask, cv.MORPH_OPEN, cvMorphKernel);
  cv.morphologyEx(cvMask, cvMask, cv.MORPH_CLOSE, cvMorphKernel);

  // Draw mask to visualization canvas
  const maskRgba = new cv.Mat();
  cv.cvtColor(cvMask, maskRgba, cv.COLOR_GRAY2RGBA);
  const maskData = new ImageData(new Uint8ClampedArray(maskRgba.data), PROCESS_W, PROCESS_H);
  const tempCanvas2 = document.createElement('canvas');
  tempCanvas2.width = PROCESS_W;
  tempCanvas2.height = PROCESS_H;
  const tempCtx2 = tempCanvas2.getContext('2d');
  tempCtx2.putImageData(maskData, 0, 0);
  maskCtx.imageSmoothingEnabled = false;
  maskCtx.drawImage(tempCanvas2, 0, 0, 480, 360);
  maskRgba.delete();

  // Find contours
  cvContours.delete();
  cvHierarchy.delete();
  cvContours = new cv.MatVector();
  cvHierarchy = new cv.Mat();
  cv.findContours(cvMask, cvContours, cvHierarchy, cv.RETR_EXTERNAL, cv.CHAIN_APPROX_SIMPLE);

  low1.delete(); high1.delete(); low2.delete(); high2.delete();

  const pixelCount = cv.countNonZero(cvMask);

  // Find largest contour
  let maxAreaVal = 0, maxIdx = -1;
  for (let i = 0; i < cvContours.size(); i++) {
    const area = cv.contourArea(cvContours.get(i));
    if (area > maxAreaVal) { maxAreaVal = area; maxIdx = i; }
  }

  if (maxIdx < 0 || maxAreaVal < minArea) {
    return { detected: false, pixelCount, contourCount: cvContours.size(), maxArea: maxAreaVal };
  }

  const rect = cv.minAreaRect(cvContours.get(maxIdx));
  const center = rect.center;
  const size = rect.size;
  let angle = rect.angle;
  let length, width;
  if (size.width < size.height) {
    length = size.height; width = size.width;
  } else {
    length = size.width; width = size.height;
    angle = angle + 90;
  }
  const angleRad = (angle * Math.PI) / 180;

  return {
    detected: true,
    centerX: center.x / PROCESS_W,
    centerY: center.y / PROCESS_H,
    angle: angleRad,
    length: length / PROCESS_W,
    pixelCount,
    contourCount: cvContours.size(),
    maxArea: maxAreaVal,
    rectWidth: width,
    rectLength: length,
  };
}

async function startCam() {
  try {
    const stream = await navigator.mediaDevices.getUserMedia({
      video: { width: 640, height: 480, facingMode: 'user' },
      audio: false,
    });
    video.srcObject = stream;
    await new Promise(r => { video.onloadeddata = r; });
    infoDiv.textContent = 'Webcam ready. Waiting for OpenCV...';
    await waitForOpenCV();
    infoDiv.textContent = 'Processing...';
    requestAnimationFrame(loop);
  } catch (err) {
    infoDiv.innerHTML = '<span style="color:red">Webcam error: ' + err.message + '</span>';
  }
}

function loop() {
  if (video.readyState < video.HAVE_CURRENT_DATA) {
    requestAnimationFrame(loop);
    return;
  }

  procCtx.drawImage(video, 0, 0, PROCESS_W, PROCESS_H);
  const imageData = procCtx.getImageData(0, 0, PROCESS_W, PROCESS_H);

  let result;
  let backend = 'Manual';

  if (cvLoaded) {
    try {
      result = detectOpenCV(imageData);
      backend = 'OpenCV';
    } catch (e) {
      console.warn('OpenCV error:', e);
      cvLoaded = false;
    }
  }

  // Clear overlay
  overlayCtx.clearRect(0, 0, 640, 480);

  if (result && result.detected) {
    const screenX = result.centerX * 640;
    const screenY = result.centerY * 480;
    const screenLen = result.length * 640;

    // Draw detected stick line
    overlayCtx.strokeStyle = '#0f0';
    overlayCtx.lineWidth = 3;
    overlayCtx.beginPath();
    overlayCtx.moveTo(
      screenX - Math.cos(result.angle) * screenLen / 2,
      screenY - Math.sin(result.angle) * screenLen / 2
    );
    overlayCtx.lineTo(
      screenX + Math.cos(result.angle) * screenLen / 2,
      screenY + Math.sin(result.angle) * screenLen / 2
    );
    overlayCtx.stroke();

    // Center dot
    overlayCtx.fillStyle = '#0f0';
    overlayCtx.beginPath();
    overlayCtx.arc(screenX, screenY, 8, 0, Math.PI * 2);
    overlayCtx.fill();

    overlayCtx.fillStyle = '#0f0';
    overlayCtx.font = '16px monospace';
    overlayCtx.fillText(`DETECTED (${result.pixelCount}px, ${result.contourCount} contours)`, screenX + 15, screenY - 10);
  }

  // Info panel
  const pixelCount = result ? result.pixelCount : 0;
  const pct = (pixelCount / (PROCESS_W * PROCESS_H) * 100).toFixed(1);
  const detected = result && result.detected;
  const barColor = detected ? '#0a0' : '#a00';
  const barWidth = Math.min(100, detected ? 100 : (result ? result.maxArea / parseInt(sliders.minArea.value) * 100 : 0));

  infoDiv.innerHTML = `
    <b>Backend:</b> ${backend}<br>
    <b>Status:</b> ${detected
      ? '<span class="detected">DETECTED</span>'
      : '<span class="not-detected">NOT DETECTED</span>'}<br>
    <b>Red pixels:</b> ${pixelCount} / ${PROCESS_W * PROCESS_H} (${pct}%)
    <div class="bar-wrap"><div class="bar-fill" style="width:${barWidth}%;background:${barColor}"></div></div><br>
    <b>Contours:</b> ${result ? result.contourCount : 0} | <b>Largest area:</b> ${result ? result.maxArea.toFixed(0) : 0} (need ${sliders.minArea.value})<br>
    ${detected ? `
    <b>Center:</b> (${result.centerX.toFixed(3)}, ${result.centerY.toFixed(3)})<br>
    <b>Angle:</b> ${(result.angle * 180 / Math.PI).toFixed(1)} degrees<br>
    <b>Bounding box:</b> ${result.rectWidth.toFixed(0)} x ${result.rectLength.toFixed(0)} px<br>
    <b>Length:</b> ${result.length.toFixed(3)} (normalized)
    ` : `
    <b>Tip:</b> Click on a red pixel in the webcam feed to see its HSV values, then adjust thresholds.
    `}
  `;

  requestAnimationFrame(loop);
}

startCam();
</script>
</body>
</html>
